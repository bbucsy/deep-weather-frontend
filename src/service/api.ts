/* tslint:disable */
/* eslint-disable */
/**
 * Deep-Weather api
 * API description for the deep-weather project
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from './configuration'
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios'
// Some imports not used depending on template conditions
// @ts-ignore
import {
    DUMMY_BASE_URL,
    assertParamExists,
    setApiKeyToObject,
    setBasicAuthToObject,
    setBearerAuthToObject,
    setOAuthToObject,
    setSearchParams,
    serializeDataIfNeeded,
    toPathString,
    createRequestFunction,
} from './common'
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base'

/**
 *
 * @export
 * @interface CityDto
 */
export interface CityDto {
    /**
     * Connected Neural models
     * @type {Array<NeuralModelBase>}
     * @memberof CityDto
     */
    neuralModels: Array<NeuralModelBase>
    /**
     * ID of the city
     * @type {number}
     * @memberof CityDto
     */
    id: number
    /**
     * Name of the city
     * @type {string}
     * @memberof CityDto
     */
    name: string
    /**
     * Latitude
     * @type {number}
     * @memberof CityDto
     */
    lat: number
    /**
     * Longitude
     * @type {number}
     * @memberof CityDto
     */
    lon: number
}
/**
 *
 * @export
 * @interface CreateCityDto
 */
export interface CreateCityDto {
    /**
     *
     * @type {string}
     * @memberof CreateCityDto
     */
    name: string
    /**
     *
     * @type {number}
     * @memberof CreateCityDto
     */
    lon: number
    /**
     *
     * @type {number}
     * @memberof CreateCityDto
     */
    lat: number
}
/**
 *
 * @export
 * @interface CreateModelDto
 */
export interface CreateModelDto {
    /**
     * Name of the neural network model
     * @type {string}
     * @memberof CreateModelDto
     */
    name: string
    /**
     * The number of epochs the initial training will user
     * @type {number}
     * @memberof CreateModelDto
     */
    epochs: number
    /**
     * The id of the city the model is attached to
     * @type {number}
     * @memberof CreateModelDto
     */
    city: number
    /**
     * Number of hidden layers
     * @type {number}
     * @memberof CreateModelDto
     */
    hiddenLayerCount: number
    /**
     * Number of LSTM units in the first layer
     * @type {number}
     * @memberof CreateModelDto
     */
    lstm_count: number
}
/**
 *
 * @export
 * @interface CreateResponseDto
 */
export interface CreateResponseDto {
    /**
     * The id of the prediction the response is submitted for
     * @type {number}
     * @memberof CreateResponseDto
     */
    prediction_id: number
    /**
     * The weather label the user wants to submit to the prediction
     * @type {number}
     * @memberof CreateResponseDto
     */
    response: number
}
/**
 *
 * @export
 * @interface LoginDto
 */
export interface LoginDto {
    /**
     *
     * @type {string}
     * @memberof LoginDto
     */
    username: string
    /**
     *
     * @type {string}
     * @memberof LoginDto
     */
    password: string
}
/**
 *
 * @export
 * @interface LoginResponseDto
 */
export interface LoginResponseDto {
    /**
     *
     * @type {string}
     * @memberof LoginResponseDto
     */
    access_token: string
}
/**
 *
 * @export
 * @interface NeuralModelBase
 */
export interface NeuralModelBase {
    /**
     *
     * @type {number}
     * @memberof NeuralModelBase
     */
    id: number
    /**
     *
     * @type {string}
     * @memberof NeuralModelBase
     */
    name: string
}
/**
 *
 * @export
 * @interface NeuralModelDto
 */
export interface NeuralModelDto {
    /**
     *
     * @type {number}
     * @memberof NeuralModelDto
     */
    id: number
    /**
     *
     * @type {string}
     * @memberof NeuralModelDto
     */
    name: string
    /**
     *
     * @type {number}
     * @memberof NeuralModelDto
     */
    epochs: number
    /**
     *
     * @type {number}
     * @memberof NeuralModelDto
     */
    hiddenLayerCount: number
    /**
     *
     * @type {number}
     * @memberof NeuralModelDto
     */
    lstm_count: number
    /**
     *
     * @type {number}
     * @memberof NeuralModelDto
     */
    accuracy: number
    /**
     *
     * @type {number}
     * @memberof NeuralModelDto
     */
    status: number
    /**
     *
     * @type {ResponseListDtoModel}
     * @memberof NeuralModelDto
     */
    city: ResponseListDtoModel
}
/**
 *
 * @export
 * @interface NeuralModelListDto
 */
export interface NeuralModelListDto {
    /**
     *
     * @type {number}
     * @memberof NeuralModelListDto
     */
    id: number
    /**
     *
     * @type {string}
     * @memberof NeuralModelListDto
     */
    name: string
    /**
     *
     * @type {number}
     * @memberof NeuralModelListDto
     */
    status: number
}
/**
 *
 * @export
 * @interface PredictionListDto
 */
export interface PredictionListDto {
    /**
     * Id of the prediction
     * @type {number}
     * @memberof PredictionListDto
     */
    id: number
    /**
     * The end of the time window the prediction is meant for
     * @type {number}
     * @memberof PredictionListDto
     */
    predictionTime: number
    /**
     * The weather label code, the neural network predicted
     * @type {number}
     * @memberof PredictionListDto
     */
    predictedLabel: number
    /**
     * The most voted weather labels by the users
     * @type {number}
     * @memberof PredictionListDto
     */
    userResponseLabel: number
    /**
     *
     * @type {ResponseListDtoModel}
     * @memberof PredictionListDto
     */
    model: ResponseListDtoModel
    /**
     *
     * @type {ResponseListDtoModel}
     * @memberof PredictionListDto
     */
    city: ResponseListDtoModel
}
/**
 *
 * @export
 * @interface ResponseListDto
 */
export interface ResponseListDto {
    /**
     * Id of response
     * @type {number}
     * @memberof ResponseListDto
     */
    id: number
    /**
     * Date of response creation in ISO string format
     * @type {string}
     * @memberof ResponseListDto
     */
    created_at: string
    /**
     *
     * @type {ResponseListDtoModel}
     * @memberof ResponseListDto
     */
    model: ResponseListDtoModel
    /**
     * The weather label the neural model predicted
     * @type {number}
     * @memberof ResponseListDto
     */
    prediction: number
    /**
     * The response the user submitted
     * @type {number}
     * @memberof ResponseListDto
     */
    userResponse: number
}
/**
 *
 * @export
 * @interface ResponseListDtoModel
 */
export interface ResponseListDtoModel {
    /**
     *
     * @type {number}
     * @memberof ResponseListDtoModel
     */
    id?: number
    /**
     *
     * @type {string}
     * @memberof ResponseListDtoModel
     */
    name?: string
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function(configuration?: Configuration) {
    return {
        /**
         *
         * @param {LoginDto} loginDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (loginDto: LoginDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginDto' is not null or undefined
            assertParamExists('login', 'loginDto', loginDto)
            const localVarPath = `/auth/login`
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
            let baseOptions
            if (configuration) {
                baseOptions = configuration.baseOptions
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
            const localVarHeaderParameter = {} as any
            const localVarQueryParameter = {} as any

            localVarHeaderParameter['Content-Type'] = 'application/json'

            setSearchParams(localVarUrlObj, localVarQueryParameter)
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            }
            localVarRequestOptions.data = serializeDataIfNeeded(loginDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            }
        },
        /**
         *
         * @param {LoginDto} loginDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register: async (loginDto: LoginDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginDto' is not null or undefined
            assertParamExists('register', 'loginDto', loginDto)
            const localVarPath = `/auth/register`
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
            let baseOptions
            if (configuration) {
                baseOptions = configuration.baseOptions
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
            const localVarHeaderParameter = {} as any
            const localVarQueryParameter = {} as any

            localVarHeaderParameter['Content-Type'] = 'application/json'

            setSearchParams(localVarUrlObj, localVarQueryParameter)
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            }
            localVarRequestOptions.data = serializeDataIfNeeded(loginDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            }
        },
    }
}

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {LoginDto} loginDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(
            loginDto: LoginDto,
            options?: AxiosRequestConfig
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(loginDto, options)
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
        },
        /**
         *
         * @param {LoginDto} loginDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async register(
            loginDto: LoginDto,
            options?: AxiosRequestConfig
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.register(loginDto, options)
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
        },
    }
}

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function(configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         *
         * @param {LoginDto} loginDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(loginDto: LoginDto, options?: any): AxiosPromise<LoginResponseDto> {
            return localVarFp.login(loginDto, options).then(request => request(axios, basePath))
        },
        /**
         *
         * @param {LoginDto} loginDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(loginDto: LoginDto, options?: any): AxiosPromise<LoginResponseDto> {
            return localVarFp.register(loginDto, options).then(request => request(axios, basePath))
        },
    }
}

/**
 * AuthApi - interface
 * @export
 * @interface AuthApi
 */
export interface AuthApiInterface {
    /**
     *
     * @param {LoginDto} loginDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    login(loginDto: LoginDto, options?: AxiosRequestConfig): AxiosPromise<LoginResponseDto>

    /**
     *
     * @param {LoginDto} loginDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    register(loginDto: LoginDto, options?: AxiosRequestConfig): AxiosPromise<LoginResponseDto>
}

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI implements AuthApiInterface {
    /**
     *
     * @param {LoginDto} loginDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public login(loginDto: LoginDto, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration)
            .login(loginDto, options)
            .then(request => request(this.axios, this.basePath))
    }

    /**
     *
     * @param {LoginDto} loginDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public register(loginDto: LoginDto, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration)
            .register(loginDto, options)
            .then(request => request(this.axios, this.basePath))
    }
}

/**
 * CityApi - axios parameter creator
 * @export
 */
export const CityApiAxiosParamCreator = function(configuration?: Configuration) {
    return {
        /**
         * Creates a new city
         * @param {CreateCityDto} createCityDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (createCityDto: CreateCityDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createCityDto' is not null or undefined
            assertParamExists('create', 'createCityDto', createCityDto)
            const localVarPath = `/city`
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
            let baseOptions
            if (configuration) {
                baseOptions = configuration.baseOptions
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
            const localVarHeaderParameter = {} as any
            const localVarQueryParameter = {} as any

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json'

            setSearchParams(localVarUrlObj, localVarQueryParameter)
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            }
            localVarRequestOptions.data = serializeDataIfNeeded(createCityDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            }
        },
        /**
         * Returns all cities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/city`
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
            let baseOptions
            if (configuration) {
                baseOptions = configuration.baseOptions
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
            const localVarHeaderParameter = {} as any
            const localVarQueryParameter = {} as any

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter)
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            }
        },
        /**
         * Returns a specific city
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOne: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('findOne', 'id', id)
            const localVarPath = `/city/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)))
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
            let baseOptions
            if (configuration) {
                baseOptions = configuration.baseOptions
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
            const localVarHeaderParameter = {} as any
            const localVarQueryParameter = {} as any

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter)
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            }
        },
        /**
         * Deletes a specific city
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        remove: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('remove', 'id', id)
            const localVarPath = `/city/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)))
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
            let baseOptions
            if (configuration) {
                baseOptions = configuration.baseOptions
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
            const localVarHeaderParameter = {} as any
            const localVarQueryParameter = {} as any

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter)
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            }
        },
    }
}

/**
 * CityApi - functional programming interface
 * @export
 */
export const CityApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CityApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new city
         * @param {CreateCityDto} createCityDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(
            createCityDto: CreateCityDto,
            options?: AxiosRequestConfig
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(createCityDto, options)
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
        },
        /**
         * Returns all cities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAll(
            options?: AxiosRequestConfig
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CityDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAll(options)
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
        },
        /**
         * Returns a specific city
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findOne(
            id: number,
            options?: AxiosRequestConfig
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CityDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findOne(id, options)
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
        },
        /**
         * Deletes a specific city
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async remove(
            id: string,
            options?: AxiosRequestConfig
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.remove(id, options)
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
        },
    }
}

/**
 * CityApi - factory interface
 * @export
 */
export const CityApiFactory = function(configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CityApiFp(configuration)
    return {
        /**
         * Creates a new city
         * @param {CreateCityDto} createCityDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(createCityDto: CreateCityDto, options?: any): AxiosPromise<void> {
            return localVarFp.create(createCityDto, options).then(request => request(axios, basePath))
        },
        /**
         * Returns all cities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAll(options?: any): AxiosPromise<Array<CityDto>> {
            return localVarFp.findAll(options).then(request => request(axios, basePath))
        },
        /**
         * Returns a specific city
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOne(id: number, options?: any): AxiosPromise<CityDto> {
            return localVarFp.findOne(id, options).then(request => request(axios, basePath))
        },
        /**
         * Deletes a specific city
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        remove(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.remove(id, options).then(request => request(axios, basePath))
        },
    }
}

/**
 * CityApi - interface
 * @export
 * @interface CityApi
 */
export interface CityApiInterface {
    /**
     * Creates a new city
     * @param {CreateCityDto} createCityDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CityApiInterface
     */
    create(createCityDto: CreateCityDto, options?: AxiosRequestConfig): AxiosPromise<void>

    /**
     * Returns all cities
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CityApiInterface
     */
    findAll(options?: AxiosRequestConfig): AxiosPromise<Array<CityDto>>

    /**
     * Returns a specific city
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CityApiInterface
     */
    findOne(id: number, options?: AxiosRequestConfig): AxiosPromise<CityDto>

    /**
     * Deletes a specific city
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CityApiInterface
     */
    remove(id: string, options?: AxiosRequestConfig): AxiosPromise<void>
}

/**
 * CityApi - object-oriented interface
 * @export
 * @class CityApi
 * @extends {BaseAPI}
 */
export class CityApi extends BaseAPI implements CityApiInterface {
    /**
     * Creates a new city
     * @param {CreateCityDto} createCityDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CityApi
     */
    public create(createCityDto: CreateCityDto, options?: AxiosRequestConfig) {
        return CityApiFp(this.configuration)
            .create(createCityDto, options)
            .then(request => request(this.axios, this.basePath))
    }

    /**
     * Returns all cities
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CityApi
     */
    public findAll(options?: AxiosRequestConfig) {
        return CityApiFp(this.configuration)
            .findAll(options)
            .then(request => request(this.axios, this.basePath))
    }

    /**
     * Returns a specific city
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CityApi
     */
    public findOne(id: number, options?: AxiosRequestConfig) {
        return CityApiFp(this.configuration)
            .findOne(id, options)
            .then(request => request(this.axios, this.basePath))
    }

    /**
     * Deletes a specific city
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CityApi
     */
    public remove(id: string, options?: AxiosRequestConfig) {
        return CityApiFp(this.configuration)
            .remove(id, options)
            .then(request => request(this.axios, this.basePath))
    }
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function(configuration?: Configuration) {
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        index: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/`
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
            let baseOptions
            if (configuration) {
                baseOptions = configuration.baseOptions
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
            const localVarHeaderParameter = {} as any
            const localVarQueryParameter = {} as any

            setSearchParams(localVarUrlObj, localVarQueryParameter)
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            }
        },
    }
}

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async index(
            options?: AxiosRequestConfig
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.index(options)
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
        },
    }
}

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function(configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        index(options?: any): AxiosPromise<void> {
            return localVarFp.index(options).then(request => request(axios, basePath))
        },
    }
}

/**
 * DefaultApi - interface
 * @export
 * @interface DefaultApi
 */
export interface DefaultApiInterface {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    index(options?: AxiosRequestConfig): AxiosPromise<void>
}

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI implements DefaultApiInterface {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public index(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration)
            .index(options)
            .then(request => request(this.axios, this.basePath))
    }
}

/**
 * NeuralModelApi - axios parameter creator
 * @export
 */
export const NeuralModelApiAxiosParamCreator = function(configuration?: Configuration) {
    return {
        /**
         * Cretes a new Neural model, and starts a Pre-Train job with a set of training data.
         * @param {CreateModelDto} createModelDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createModel: async (createModelDto: CreateModelDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createModelDto' is not null or undefined
            assertParamExists('createModel', 'createModelDto', createModelDto)
            const localVarPath = `/neural-model`
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
            let baseOptions
            if (configuration) {
                baseOptions = configuration.baseOptions
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
            const localVarHeaderParameter = {} as any
            const localVarQueryParameter = {} as any

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json'

            setSearchParams(localVarUrlObj, localVarQueryParameter)
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            }
            localVarRequestOptions.data = serializeDataIfNeeded(createModelDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            }
        },
        /**
         * Finds all neural models
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllModels: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/neural-model`
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
            let baseOptions
            if (configuration) {
                baseOptions = configuration.baseOptions
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
            const localVarHeaderParameter = {} as any
            const localVarQueryParameter = {} as any

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter)
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            }
        },
        /**
         * Gets a NeuralModel with a specific ID
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOne: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('findOne', 'id', id)
            const localVarPath = `/neural-model/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)))
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
            let baseOptions
            if (configuration) {
                baseOptions = configuration.baseOptions
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
            const localVarHeaderParameter = {} as any
            const localVarQueryParameter = {} as any

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter)
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            }
        },
        /**
         * Forcefully  starts a prediction background job (Normally started by cron)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        predict: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/neural-model/predict`
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
            let baseOptions
            if (configuration) {
                baseOptions = configuration.baseOptions
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
            const localVarHeaderParameter = {} as any
            const localVarQueryParameter = {} as any

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter)
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            }
        },
        /**
         * Forcefully  starts a Re-Train background job (Normally started by cron)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrain: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/neural-model/retrain`
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
            let baseOptions
            if (configuration) {
                baseOptions = configuration.baseOptions
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
            const localVarHeaderParameter = {} as any
            const localVarQueryParameter = {} as any

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter)
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            }
        },
    }
}

/**
 * NeuralModelApi - functional programming interface
 * @export
 */
export const NeuralModelApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NeuralModelApiAxiosParamCreator(configuration)
    return {
        /**
         * Cretes a new Neural model, and starts a Pre-Train job with a set of training data.
         * @param {CreateModelDto} createModelDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createModel(
            createModelDto: CreateModelDto,
            options?: AxiosRequestConfig
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createModel(createModelDto, options)
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
        },
        /**
         * Finds all neural models
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllModels(
            options?: AxiosRequestConfig
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NeuralModelListDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllModels(options)
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
        },
        /**
         * Gets a NeuralModel with a specific ID
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findOne(
            id: string,
            options?: AxiosRequestConfig
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NeuralModelDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findOne(id, options)
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
        },
        /**
         * Forcefully  starts a prediction background job (Normally started by cron)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async predict(
            options?: AxiosRequestConfig
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.predict(options)
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
        },
        /**
         * Forcefully  starts a Re-Train background job (Normally started by cron)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrain(
            options?: AxiosRequestConfig
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrain(options)
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
        },
    }
}

/**
 * NeuralModelApi - factory interface
 * @export
 */
export const NeuralModelApiFactory = function(configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NeuralModelApiFp(configuration)
    return {
        /**
         * Cretes a new Neural model, and starts a Pre-Train job with a set of training data.
         * @param {CreateModelDto} createModelDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createModel(createModelDto: CreateModelDto, options?: any): AxiosPromise<void> {
            return localVarFp.createModel(createModelDto, options).then(request => request(axios, basePath))
        },
        /**
         * Finds all neural models
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllModels(options?: any): AxiosPromise<Array<NeuralModelListDto>> {
            return localVarFp.findAllModels(options).then(request => request(axios, basePath))
        },
        /**
         * Gets a NeuralModel with a specific ID
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOne(id: string, options?: any): AxiosPromise<NeuralModelDto> {
            return localVarFp.findOne(id, options).then(request => request(axios, basePath))
        },
        /**
         * Forcefully  starts a prediction background job (Normally started by cron)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        predict(options?: any): AxiosPromise<void> {
            return localVarFp.predict(options).then(request => request(axios, basePath))
        },
        /**
         * Forcefully  starts a Re-Train background job (Normally started by cron)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrain(options?: any): AxiosPromise<void> {
            return localVarFp.retrain(options).then(request => request(axios, basePath))
        },
    }
}

/**
 * NeuralModelApi - interface
 * @export
 * @interface NeuralModelApi
 */
export interface NeuralModelApiInterface {
    /**
     * Cretes a new Neural model, and starts a Pre-Train job with a set of training data.
     * @param {CreateModelDto} createModelDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NeuralModelApiInterface
     */
    createModel(createModelDto: CreateModelDto, options?: AxiosRequestConfig): AxiosPromise<void>

    /**
     * Finds all neural models
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NeuralModelApiInterface
     */
    findAllModels(options?: AxiosRequestConfig): AxiosPromise<Array<NeuralModelListDto>>

    /**
     * Gets a NeuralModel with a specific ID
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NeuralModelApiInterface
     */
    findOne(id: string, options?: AxiosRequestConfig): AxiosPromise<NeuralModelDto>

    /**
     * Forcefully  starts a prediction background job (Normally started by cron)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NeuralModelApiInterface
     */
    predict(options?: AxiosRequestConfig): AxiosPromise<void>

    /**
     * Forcefully  starts a Re-Train background job (Normally started by cron)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NeuralModelApiInterface
     */
    retrain(options?: AxiosRequestConfig): AxiosPromise<void>
}

/**
 * NeuralModelApi - object-oriented interface
 * @export
 * @class NeuralModelApi
 * @extends {BaseAPI}
 */
export class NeuralModelApi extends BaseAPI implements NeuralModelApiInterface {
    /**
     * Cretes a new Neural model, and starts a Pre-Train job with a set of training data.
     * @param {CreateModelDto} createModelDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NeuralModelApi
     */
    public createModel(createModelDto: CreateModelDto, options?: AxiosRequestConfig) {
        return NeuralModelApiFp(this.configuration)
            .createModel(createModelDto, options)
            .then(request => request(this.axios, this.basePath))
    }

    /**
     * Finds all neural models
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NeuralModelApi
     */
    public findAllModels(options?: AxiosRequestConfig) {
        return NeuralModelApiFp(this.configuration)
            .findAllModels(options)
            .then(request => request(this.axios, this.basePath))
    }

    /**
     * Gets a NeuralModel with a specific ID
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NeuralModelApi
     */
    public findOne(id: string, options?: AxiosRequestConfig) {
        return NeuralModelApiFp(this.configuration)
            .findOne(id, options)
            .then(request => request(this.axios, this.basePath))
    }

    /**
     * Forcefully  starts a prediction background job (Normally started by cron)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NeuralModelApi
     */
    public predict(options?: AxiosRequestConfig) {
        return NeuralModelApiFp(this.configuration)
            .predict(options)
            .then(request => request(this.axios, this.basePath))
    }

    /**
     * Forcefully  starts a Re-Train background job (Normally started by cron)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NeuralModelApi
     */
    public retrain(options?: AxiosRequestConfig) {
        return NeuralModelApiFp(this.configuration)
            .retrain(options)
            .then(request => request(this.axios, this.basePath))
    }
}

/**
 * PredictionsApi - axios parameter creator
 * @export
 */
export const PredictionsApiAxiosParamCreator = function(configuration?: Configuration) {
    return {
        /**
         * Creates a user response to a specified prediction
         * @param {CreateResponseDto} createResponseDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addResponse: async (
            createResponseDto: CreateResponseDto,
            options: AxiosRequestConfig = {}
        ): Promise<RequestArgs> => {
            // verify required parameter 'createResponseDto' is not null or undefined
            assertParamExists('addResponse', 'createResponseDto', createResponseDto)
            const localVarPath = `/predictions/responses`
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
            let baseOptions
            if (configuration) {
                baseOptions = configuration.baseOptions
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
            const localVarHeaderParameter = {} as any
            const localVarQueryParameter = {} as any

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json'

            setSearchParams(localVarUrlObj, localVarQueryParameter)
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            }
            localVarRequestOptions.data = serializeDataIfNeeded(
                createResponseDto,
                localVarRequestOptions,
                configuration
            )

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            }
        },
        /**
         * Returns all predictions, that are in the current time window
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentPredictions: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/predictions`
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
            let baseOptions
            if (configuration) {
                baseOptions = configuration.baseOptions
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
            const localVarHeaderParameter = {} as any
            const localVarQueryParameter = {} as any

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter)
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            }
        },
        /**
         * Returns all predictions predicted to a given city. Only those predictions will show up, that are in the time window of the time of calling the endpoint
         * @param {number} cityId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentPredictionsOfCity: async (cityId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cityId' is not null or undefined
            assertParamExists('currentPredictionsOfCity', 'cityId', cityId)
            const localVarPath = `/predictions/city/{city_id}`.replace(
                `{${'city_id'}}`,
                encodeURIComponent(String(cityId))
            )
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
            let baseOptions
            if (configuration) {
                baseOptions = configuration.baseOptions
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
            const localVarHeaderParameter = {} as any
            const localVarQueryParameter = {} as any

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter)
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            }
        },
        /**
         * Gets all user responses to weather predictions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        responses: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/predictions/responses`
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
            let baseOptions
            if (configuration) {
                baseOptions = configuration.baseOptions
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
            const localVarHeaderParameter = {} as any
            const localVarQueryParameter = {} as any

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter)
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            }
        },
    }
}

/**
 * PredictionsApi - functional programming interface
 * @export
 */
export const PredictionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PredictionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a user response to a specified prediction
         * @param {CreateResponseDto} createResponseDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addResponse(
            createResponseDto: CreateResponseDto,
            options?: AxiosRequestConfig
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addResponse(createResponseDto, options)
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
        },
        /**
         * Returns all predictions, that are in the current time window
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async currentPredictions(
            options?: AxiosRequestConfig
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PredictionListDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.currentPredictions(options)
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
        },
        /**
         * Returns all predictions predicted to a given city. Only those predictions will show up, that are in the time window of the time of calling the endpoint
         * @param {number} cityId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async currentPredictionsOfCity(
            cityId: number,
            options?: AxiosRequestConfig
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PredictionListDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.currentPredictionsOfCity(cityId, options)
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
        },
        /**
         * Gets all user responses to weather predictions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async responses(
            options?: AxiosRequestConfig
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResponseListDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.responses(options)
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
        },
    }
}

/**
 * PredictionsApi - factory interface
 * @export
 */
export const PredictionsApiFactory = function(configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PredictionsApiFp(configuration)
    return {
        /**
         * Creates a user response to a specified prediction
         * @param {CreateResponseDto} createResponseDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addResponse(createResponseDto: CreateResponseDto, options?: any): AxiosPromise<void> {
            return localVarFp.addResponse(createResponseDto, options).then(request => request(axios, basePath))
        },
        /**
         * Returns all predictions, that are in the current time window
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentPredictions(options?: any): AxiosPromise<Array<PredictionListDto>> {
            return localVarFp.currentPredictions(options).then(request => request(axios, basePath))
        },
        /**
         * Returns all predictions predicted to a given city. Only those predictions will show up, that are in the time window of the time of calling the endpoint
         * @param {number} cityId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentPredictionsOfCity(cityId: number, options?: any): AxiosPromise<Array<PredictionListDto>> {
            return localVarFp.currentPredictionsOfCity(cityId, options).then(request => request(axios, basePath))
        },
        /**
         * Gets all user responses to weather predictions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        responses(options?: any): AxiosPromise<Array<ResponseListDto>> {
            return localVarFp.responses(options).then(request => request(axios, basePath))
        },
    }
}

/**
 * PredictionsApi - interface
 * @export
 * @interface PredictionsApi
 */
export interface PredictionsApiInterface {
    /**
     * Creates a user response to a specified prediction
     * @param {CreateResponseDto} createResponseDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PredictionsApiInterface
     */
    addResponse(createResponseDto: CreateResponseDto, options?: AxiosRequestConfig): AxiosPromise<void>

    /**
     * Returns all predictions, that are in the current time window
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PredictionsApiInterface
     */
    currentPredictions(options?: AxiosRequestConfig): AxiosPromise<Array<PredictionListDto>>

    /**
     * Returns all predictions predicted to a given city. Only those predictions will show up, that are in the time window of the time of calling the endpoint
     * @param {number} cityId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PredictionsApiInterface
     */
    currentPredictionsOfCity(cityId: number, options?: AxiosRequestConfig): AxiosPromise<Array<PredictionListDto>>

    /**
     * Gets all user responses to weather predictions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PredictionsApiInterface
     */
    responses(options?: AxiosRequestConfig): AxiosPromise<Array<ResponseListDto>>
}

/**
 * PredictionsApi - object-oriented interface
 * @export
 * @class PredictionsApi
 * @extends {BaseAPI}
 */
export class PredictionsApi extends BaseAPI implements PredictionsApiInterface {
    /**
     * Creates a user response to a specified prediction
     * @param {CreateResponseDto} createResponseDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PredictionsApi
     */
    public addResponse(createResponseDto: CreateResponseDto, options?: AxiosRequestConfig) {
        return PredictionsApiFp(this.configuration)
            .addResponse(createResponseDto, options)
            .then(request => request(this.axios, this.basePath))
    }

    /**
     * Returns all predictions, that are in the current time window
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PredictionsApi
     */
    public currentPredictions(options?: AxiosRequestConfig) {
        return PredictionsApiFp(this.configuration)
            .currentPredictions(options)
            .then(request => request(this.axios, this.basePath))
    }

    /**
     * Returns all predictions predicted to a given city. Only those predictions will show up, that are in the time window of the time of calling the endpoint
     * @param {number} cityId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PredictionsApi
     */
    public currentPredictionsOfCity(cityId: number, options?: AxiosRequestConfig) {
        return PredictionsApiFp(this.configuration)
            .currentPredictionsOfCity(cityId, options)
            .then(request => request(this.axios, this.basePath))
    }

    /**
     * Gets all user responses to weather predictions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PredictionsApi
     */
    public responses(options?: AxiosRequestConfig) {
        return PredictionsApiFp(this.configuration)
            .responses(options)
            .then(request => request(this.axios, this.basePath))
    }
}
